MODULE UTIL_TTRC_MOD

USE YOMTRC, ONLY : TTRC


INTERFACE SAVE
MODULE PROCEDURE SAVE_TTRC
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE LOAD_TTRC
END INTERFACE

INTERFACE COPY
MODULE PROCEDURE COPY_TTRC
END INTERFACE

INTERFACE WIPE
MODULE PROCEDURE WIPE_TTRC
END INTERFACE



CONTAINS

SUBROUTINE SAVE_TTRC (KLUN, YD)
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
CLASS (TTRC), INTENT (IN), TARGET :: YD
LOGICAL :: LGDEOSI, LGDEOTI, LGDEOTI2, LGEOLT, LGEOXT, LGFLUXC, LGMIXP, LGMU0, LGMU0_MAX, LGMU0_MIN
LOGICAL :: LGRPROX, LGRSURF, LGUEOSI, LGUEOTI, LGUEOTI2

LGRSURF = ALLOCATED (YD%GRSURF)
WRITE (KLUN) LGRSURF
IF (LGRSURF) THEN
  WRITE (KLUN) LBOUND (YD%GRSURF)
  WRITE (KLUN) UBOUND (YD%GRSURF)
  WRITE (KLUN) YD%GRSURF
ENDIF
LGDEOTI = ALLOCATED (YD%GDEOTI)
WRITE (KLUN) LGDEOTI
IF (LGDEOTI) THEN
  WRITE (KLUN) LBOUND (YD%GDEOTI)
  WRITE (KLUN) UBOUND (YD%GDEOTI)
  WRITE (KLUN) YD%GDEOTI
ENDIF
LGDEOTI2 = ALLOCATED (YD%GDEOTI2)
WRITE (KLUN) LGDEOTI2
IF (LGDEOTI2) THEN
  WRITE (KLUN) LBOUND (YD%GDEOTI2)
  WRITE (KLUN) UBOUND (YD%GDEOTI2)
  WRITE (KLUN) YD%GDEOTI2
ENDIF
LGUEOTI = ALLOCATED (YD%GUEOTI)
WRITE (KLUN) LGUEOTI
IF (LGUEOTI) THEN
  WRITE (KLUN) LBOUND (YD%GUEOTI)
  WRITE (KLUN) UBOUND (YD%GUEOTI)
  WRITE (KLUN) YD%GUEOTI
ENDIF
LGUEOTI2 = ALLOCATED (YD%GUEOTI2)
WRITE (KLUN) LGUEOTI2
IF (LGUEOTI2) THEN
  WRITE (KLUN) LBOUND (YD%GUEOTI2)
  WRITE (KLUN) UBOUND (YD%GUEOTI2)
  WRITE (KLUN) YD%GUEOTI2
ENDIF
LGEOLT = ALLOCATED (YD%GEOLT)
WRITE (KLUN) LGEOLT
IF (LGEOLT) THEN
  WRITE (KLUN) LBOUND (YD%GEOLT)
  WRITE (KLUN) UBOUND (YD%GEOLT)
  WRITE (KLUN) YD%GEOLT
ENDIF
LGEOXT = ALLOCATED (YD%GEOXT)
WRITE (KLUN) LGEOXT
IF (LGEOXT) THEN
  WRITE (KLUN) LBOUND (YD%GEOXT)
  WRITE (KLUN) UBOUND (YD%GEOXT)
  WRITE (KLUN) YD%GEOXT
ENDIF
LGRPROX = ALLOCATED (YD%GRPROX)
WRITE (KLUN) LGRPROX
IF (LGRPROX) THEN
  WRITE (KLUN) LBOUND (YD%GRPROX)
  WRITE (KLUN) UBOUND (YD%GRPROX)
  WRITE (KLUN) YD%GRPROX
ENDIF
LGMIXP = ALLOCATED (YD%GMIXP)
WRITE (KLUN) LGMIXP
IF (LGMIXP) THEN
  WRITE (KLUN) LBOUND (YD%GMIXP)
  WRITE (KLUN) UBOUND (YD%GMIXP)
  WRITE (KLUN) YD%GMIXP
ENDIF
LGFLUXC = ALLOCATED (YD%GFLUXC)
WRITE (KLUN) LGFLUXC
IF (LGFLUXC) THEN
  WRITE (KLUN) LBOUND (YD%GFLUXC)
  WRITE (KLUN) UBOUND (YD%GFLUXC)
  WRITE (KLUN) YD%GFLUXC
ENDIF
LGDEOSI = ALLOCATED (YD%GDEOSI)
WRITE (KLUN) LGDEOSI
IF (LGDEOSI) THEN
  WRITE (KLUN) LBOUND (YD%GDEOSI)
  WRITE (KLUN) UBOUND (YD%GDEOSI)
  WRITE (KLUN) YD%GDEOSI
ENDIF
LGUEOSI = ALLOCATED (YD%GUEOSI)
WRITE (KLUN) LGUEOSI
IF (LGUEOSI) THEN
  WRITE (KLUN) LBOUND (YD%GUEOSI)
  WRITE (KLUN) UBOUND (YD%GUEOSI)
  WRITE (KLUN) YD%GUEOSI
ENDIF
LGMU0 = ALLOCATED (YD%GMU0)
WRITE (KLUN) LGMU0
IF (LGMU0) THEN
  WRITE (KLUN) LBOUND (YD%GMU0)
  WRITE (KLUN) UBOUND (YD%GMU0)
  WRITE (KLUN) YD%GMU0
ENDIF
LGMU0_MIN = ALLOCATED (YD%GMU0_MIN)
WRITE (KLUN) LGMU0_MIN
IF (LGMU0_MIN) THEN
  WRITE (KLUN) LBOUND (YD%GMU0_MIN)
  WRITE (KLUN) UBOUND (YD%GMU0_MIN)
  WRITE (KLUN) YD%GMU0_MIN
ENDIF
LGMU0_MAX = ALLOCATED (YD%GMU0_MAX)
WRITE (KLUN) LGMU0_MAX
IF (LGMU0_MAX) THEN
  WRITE (KLUN) LBOUND (YD%GMU0_MAX)
  WRITE (KLUN) UBOUND (YD%GMU0_MAX)
  WRITE (KLUN) YD%GMU0_MAX
ENDIF
END SUBROUTINE

SUBROUTINE LOAD_TTRC (KLUN, YD)
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
CLASS (TTRC), INTENT (OUT), TARGET :: YD
INTEGER :: IL2(2), IU2(2), IL3(3), IU3(3), IL4(4), IU4(4)
LOGICAL :: LGDEOSI, LGDEOTI, LGDEOTI2, LGEOLT, LGEOXT, LGFLUXC, LGMIXP, LGMU0, LGMU0_MAX, LGMU0_MIN
LOGICAL :: LGRPROX, LGRSURF, LGUEOSI, LGUEOTI, LGUEOTI2

READ (KLUN) LGRSURF
IF (LGRSURF) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%GRSURF (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%GRSURF
ENDIF
READ (KLUN) LGDEOTI
IF (LGDEOTI) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%GDEOTI (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%GDEOTI
ENDIF
READ (KLUN) LGDEOTI2
IF (LGDEOTI2) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%GDEOTI2 (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%GDEOTI2
ENDIF
READ (KLUN) LGUEOTI
IF (LGUEOTI) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%GUEOTI (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%GUEOTI
ENDIF
READ (KLUN) LGUEOTI2
IF (LGUEOTI2) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%GUEOTI2 (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%GUEOTI2
ENDIF
READ (KLUN) LGEOLT
IF (LGEOLT) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%GEOLT (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%GEOLT
ENDIF
READ (KLUN) LGEOXT
IF (LGEOXT) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%GEOXT (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%GEOXT
ENDIF
READ (KLUN) LGRPROX
IF (LGRPROX) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%GRPROX (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%GRPROX
ENDIF
READ (KLUN) LGMIXP
IF (LGMIXP) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%GMIXP (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%GMIXP
ENDIF
READ (KLUN) LGFLUXC
IF (LGFLUXC) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%GFLUXC (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%GFLUXC
ENDIF
READ (KLUN) LGDEOSI
IF (LGDEOSI) THEN
  READ (KLUN) IL4
  READ (KLUN) IU4
  ALLOCATE (YD%GDEOSI (IL4(1):IU4(1), IL4(2):IU4(2), IL4(3):IU4(3), IL4(4):IU4(4)))
  READ (KLUN) YD%GDEOSI
ENDIF
READ (KLUN) LGUEOSI
IF (LGUEOSI) THEN
  READ (KLUN) IL4
  READ (KLUN) IU4
  ALLOCATE (YD%GUEOSI (IL4(1):IU4(1), IL4(2):IU4(2), IL4(3):IU4(3), IL4(4):IU4(4)))
  READ (KLUN) YD%GUEOSI
ENDIF
READ (KLUN) LGMU0
IF (LGMU0) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%GMU0 (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%GMU0
ENDIF
READ (KLUN) LGMU0_MIN
IF (LGMU0_MIN) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%GMU0_MIN (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%GMU0_MIN
ENDIF
READ (KLUN) LGMU0_MAX
IF (LGMU0_MAX) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%GMU0_MAX (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%GMU0_MAX
ENDIF
END SUBROUTINE


SUBROUTINE COPY_TTRC (YD, LDCREATED)
IMPLICIT NONE
CLASS (TTRC), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED
LOGICAL :: LLCREATED
LOGICAL :: LGDEOSI, LGDEOTI, LGDEOTI2, LGEOLT, LGEOXT, LGFLUXC, LGMIXP, LGMU0, LGMU0_MAX, LGMU0_MIN
LOGICAL :: LGRPROX, LGRSURF, LGUEOSI, LGUEOTI, LGUEOTI2

LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$acc enter data create (YD)
  !$acc update device (YD)
ENDIF
LGRSURF = ALLOCATED (YD%GRSURF)
IF (LGRSURF) THEN
  !$acc enter data create (YD%GRSURF)
  !$acc update device (YD%GRSURF)
  !$acc enter data attach (YD%GRSURF)
ENDIF

LGDEOTI = ALLOCATED (YD%GDEOTI)
IF (LGDEOTI) THEN
  !$acc enter data create (YD%GDEOTI)
  !$acc update device (YD%GDEOTI)
  !$acc enter data attach (YD%GDEOTI)
ENDIF

LGDEOTI2 = ALLOCATED (YD%GDEOTI2)
IF (LGDEOTI2) THEN
  !$acc enter data create (YD%GDEOTI2)
  !$acc update device (YD%GDEOTI2)
  !$acc enter data attach (YD%GDEOTI2)
ENDIF

LGUEOTI = ALLOCATED (YD%GUEOTI)
IF (LGUEOTI) THEN
  !$acc enter data create (YD%GUEOTI)
  !$acc update device (YD%GUEOTI)
  !$acc enter data attach (YD%GUEOTI)
ENDIF

LGUEOTI2 = ALLOCATED (YD%GUEOTI2)
IF (LGUEOTI2) THEN
  !$acc enter data create (YD%GUEOTI2)
  !$acc update device (YD%GUEOTI2)
  !$acc enter data attach (YD%GUEOTI2)
ENDIF

LGEOLT = ALLOCATED (YD%GEOLT)
IF (LGEOLT) THEN
  !$acc enter data create (YD%GEOLT)
  !$acc update device (YD%GEOLT)
  !$acc enter data attach (YD%GEOLT)
ENDIF

LGEOXT = ALLOCATED (YD%GEOXT)
IF (LGEOXT) THEN
  !$acc enter data create (YD%GEOXT)
  !$acc update device (YD%GEOXT)
  !$acc enter data attach (YD%GEOXT)
ENDIF

LGRPROX = ALLOCATED (YD%GRPROX)
IF (LGRPROX) THEN
  !$acc enter data create (YD%GRPROX)
  !$acc update device (YD%GRPROX)
  !$acc enter data attach (YD%GRPROX)
ENDIF

LGMIXP = ALLOCATED (YD%GMIXP)
IF (LGMIXP) THEN
  !$acc enter data create (YD%GMIXP)
  !$acc update device (YD%GMIXP)
  !$acc enter data attach (YD%GMIXP)
ENDIF

LGFLUXC = ALLOCATED (YD%GFLUXC)
IF (LGFLUXC) THEN
  !$acc enter data create (YD%GFLUXC)
  !$acc update device (YD%GFLUXC)
  !$acc enter data attach (YD%GFLUXC)
ENDIF

LGDEOSI = ALLOCATED (YD%GDEOSI)
IF (LGDEOSI) THEN
  !$acc enter data create (YD%GDEOSI)
  !$acc update device (YD%GDEOSI)
  !$acc enter data attach (YD%GDEOSI)
ENDIF

LGUEOSI = ALLOCATED (YD%GUEOSI)
IF (LGUEOSI) THEN
  !$acc enter data create (YD%GUEOSI)
  !$acc update device (YD%GUEOSI)
  !$acc enter data attach (YD%GUEOSI)
ENDIF

LGMU0 = ALLOCATED (YD%GMU0)
IF (LGMU0) THEN
  !$acc enter data create (YD%GMU0)
  !$acc update device (YD%GMU0)
  !$acc enter data attach (YD%GMU0)
ENDIF

LGMU0_MIN = ALLOCATED (YD%GMU0_MIN)
IF (LGMU0_MIN) THEN
  !$acc enter data create (YD%GMU0_MIN)
  !$acc update device (YD%GMU0_MIN)
  !$acc enter data attach (YD%GMU0_MIN)
ENDIF

LGMU0_MAX = ALLOCATED (YD%GMU0_MAX)
IF (LGMU0_MAX) THEN
  !$acc enter data create (YD%GMU0_MAX)
  !$acc update device (YD%GMU0_MAX)
  !$acc enter data attach (YD%GMU0_MAX)
ENDIF

END SUBROUTINE

SUBROUTINE WIPE_TTRC (YD, LDDELETED)
IMPLICIT NONE
CLASS (TTRC), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED
LOGICAL :: LLDELETED
LOGICAL :: LGDEOSI, LGDEOTI, LGDEOTI2, LGEOLT, LGEOXT, LGFLUXC, LGMIXP, LGMU0, LGMU0_MAX, LGMU0_MIN
LOGICAL :: LGRPROX, LGRSURF, LGUEOSI, LGUEOTI, LGUEOTI2

LGRSURF = ALLOCATED (YD%GRSURF)
IF (LGRSURF) THEN
  !$acc exit data detach (YD%GRSURF)
  !$acc exit data delete (YD%GRSURF)
ENDIF

LGDEOTI = ALLOCATED (YD%GDEOTI)
IF (LGDEOTI) THEN
  !$acc exit data detach (YD%GDEOTI)
  !$acc exit data delete (YD%GDEOTI)
ENDIF

LGDEOTI2 = ALLOCATED (YD%GDEOTI2)
IF (LGDEOTI2) THEN
  !$acc exit data detach (YD%GDEOTI2)
  !$acc exit data delete (YD%GDEOTI2)
ENDIF

LGUEOTI = ALLOCATED (YD%GUEOTI)
IF (LGUEOTI) THEN
  !$acc exit data detach (YD%GUEOTI)
  !$acc exit data delete (YD%GUEOTI)
ENDIF

LGUEOTI2 = ALLOCATED (YD%GUEOTI2)
IF (LGUEOTI2) THEN
  !$acc exit data detach (YD%GUEOTI2)
  !$acc exit data delete (YD%GUEOTI2)
ENDIF

LGEOLT = ALLOCATED (YD%GEOLT)
IF (LGEOLT) THEN
  !$acc exit data detach (YD%GEOLT)
  !$acc exit data delete (YD%GEOLT)
ENDIF

LGEOXT = ALLOCATED (YD%GEOXT)
IF (LGEOXT) THEN
  !$acc exit data detach (YD%GEOXT)
  !$acc exit data delete (YD%GEOXT)
ENDIF

LGRPROX = ALLOCATED (YD%GRPROX)
IF (LGRPROX) THEN
  !$acc exit data detach (YD%GRPROX)
  !$acc exit data delete (YD%GRPROX)
ENDIF

LGMIXP = ALLOCATED (YD%GMIXP)
IF (LGMIXP) THEN
  !$acc exit data detach (YD%GMIXP)
  !$acc exit data delete (YD%GMIXP)
ENDIF

LGFLUXC = ALLOCATED (YD%GFLUXC)
IF (LGFLUXC) THEN
  !$acc exit data detach (YD%GFLUXC)
  !$acc exit data delete (YD%GFLUXC)
ENDIF

LGDEOSI = ALLOCATED (YD%GDEOSI)
IF (LGDEOSI) THEN
  !$acc exit data detach (YD%GDEOSI)
  !$acc exit data delete (YD%GDEOSI)
ENDIF

LGUEOSI = ALLOCATED (YD%GUEOSI)
IF (LGUEOSI) THEN
  !$acc exit data detach (YD%GUEOSI)
  !$acc exit data delete (YD%GUEOSI)
ENDIF

LGMU0 = ALLOCATED (YD%GMU0)
IF (LGMU0) THEN
  !$acc exit data detach (YD%GMU0)
  !$acc exit data delete (YD%GMU0)
ENDIF

LGMU0_MIN = ALLOCATED (YD%GMU0_MIN)
IF (LGMU0_MIN) THEN
  !$acc exit data detach (YD%GMU0_MIN)
  !$acc exit data delete (YD%GMU0_MIN)
ENDIF

LGMU0_MAX = ALLOCATED (YD%GMU0_MAX)
IF (LGMU0_MAX) THEN
  !$acc exit data detach (YD%GMU0_MAX)
  !$acc exit data delete (YD%GMU0_MAX)
ENDIF

LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$acc exit data delete (YD)
ENDIF
END SUBROUTINE



END MODULE
