MODULE UTIL_TEDYN_MOD

USE YEMDYN, ONLY : TEDYN


INTERFACE SAVE
MODULE PROCEDURE SAVE_TEDYN
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE LOAD_TEDYN
END INTERFACE

INTERFACE COPY
MODULE PROCEDURE COPY_TEDYN
END INTERFACE

INTERFACE WIPE
MODULE PROCEDURE WIPE_TEDYN
END INTERFACE



CONTAINS

SUBROUTINE SAVE_TEDYN (KLUN, YD)
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (TEDYN), INTENT (IN), TARGET :: YD
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV

LRDIVORE = ALLOCATED (YD%RDIVORE)
WRITE (KLUN) LRDIVORE
IF (LRDIVORE) THEN
  WRITE (KLUN) LBOUND (YD%RDIVORE)
  WRITE (KLUN) UBOUND (YD%RDIVORE)
  WRITE (KLUN) YD%RDIVORE
ENDIF
LRDIDIVE = ALLOCATED (YD%RDIDIVE)
WRITE (KLUN) LRDIDIVE
IF (LRDIDIVE) THEN
  WRITE (KLUN) LBOUND (YD%RDIDIVE)
  WRITE (KLUN) UBOUND (YD%RDIDIVE)
  WRITE (KLUN) YD%RDIDIVE
ENDIF
LRDITE = ALLOCATED (YD%RDITE)
WRITE (KLUN) LRDITE
IF (LRDITE) THEN
  WRITE (KLUN) LBOUND (YD%RDITE)
  WRITE (KLUN) UBOUND (YD%RDITE)
  WRITE (KLUN) YD%RDITE
ENDIF
LRDIGFLE = ALLOCATED (YD%RDIGFLE)
WRITE (KLUN) LRDIGFLE
IF (LRDIGFLE) THEN
  WRITE (KLUN) LBOUND (YD%RDIGFLE)
  WRITE (KLUN) UBOUND (YD%RDIGFLE)
  WRITE (KLUN) YD%RDIGFLE
ENDIF
LRDIPDE = ALLOCATED (YD%RDIPDE)
WRITE (KLUN) LRDIPDE
IF (LRDIPDE) THEN
  WRITE (KLUN) LBOUND (YD%RDIPDE)
  WRITE (KLUN) UBOUND (YD%RDIPDE)
  WRITE (KLUN) YD%RDIPDE
ENDIF
LRDIVDE = ALLOCATED (YD%RDIVDE)
WRITE (KLUN) LRDIVDE
IF (LRDIVDE) THEN
  WRITE (KLUN) LBOUND (YD%RDIVDE)
  WRITE (KLUN) UBOUND (YD%RDIVDE)
  WRITE (KLUN) YD%RDIVDE
ENDIF
LRDISPE = ALLOCATED (YD%RDISPE)
WRITE (KLUN) LRDISPE
IF (LRDISPE) THEN
  WRITE (KLUN) LBOUND (YD%RDISPE)
  WRITE (KLUN) UBOUND (YD%RDISPE)
  WRITE (KLUN) YD%RDISPE
ENDIF
LRDSVORE = ALLOCATED (YD%RDSVORE)
WRITE (KLUN) LRDSVORE
IF (LRDSVORE) THEN
  WRITE (KLUN) LBOUND (YD%RDSVORE)
  WRITE (KLUN) UBOUND (YD%RDSVORE)
  WRITE (KLUN) YD%RDSVORE
ENDIF
LRDSDIVE = ALLOCATED (YD%RDSDIVE)
WRITE (KLUN) LRDSDIVE
IF (LRDSDIVE) THEN
  WRITE (KLUN) LBOUND (YD%RDSDIVE)
  WRITE (KLUN) UBOUND (YD%RDSDIVE)
  WRITE (KLUN) YD%RDSDIVE
ENDIF
LRDSVDE = ALLOCATED (YD%RDSVDE)
WRITE (KLUN) LRDSVDE
IF (LRDSVDE) THEN
  WRITE (KLUN) LBOUND (YD%RDSVDE)
  WRITE (KLUN) UBOUND (YD%RDSVDE)
  WRITE (KLUN) YD%RDSVDE
ENDIF
LREFILV = ALLOCATED (YD%REFILV)
WRITE (KLUN) LREFILV
IF (LREFILV) THEN
  WRITE (KLUN) LBOUND (YD%REFILV)
  WRITE (KLUN) UBOUND (YD%REFILV)
  WRITE (KLUN) YD%REFILV
ENDIF
LREFILD = ALLOCATED (YD%REFILD)
WRITE (KLUN) LREFILD
IF (LREFILD) THEN
  WRITE (KLUN) LBOUND (YD%REFILD)
  WRITE (KLUN) UBOUND (YD%REFILD)
  WRITE (KLUN) YD%REFILD
ENDIF
WRITE (KLUN) YD%LESIDG
WRITE (KLUN) YD%RTHRESIDG
WRITE (KLUN) YD%XMALD
WRITE (KLUN) YD%TCDIS
END SUBROUTINE

SUBROUTINE LOAD_TEDYN (KLUN, YD)
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (TEDYN), INTENT (OUT), TARGET :: YD
INTEGER :: IL1(1), IU1(1), IL2(2), IU2(2), IL3(3), IU3(3)
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV

READ (KLUN) LRDIVORE
IF (LRDIVORE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDIVORE (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%RDIVORE
ENDIF
READ (KLUN) LRDIDIVE
IF (LRDIDIVE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDIDIVE (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%RDIDIVE
ENDIF
READ (KLUN) LRDITE
IF (LRDITE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDITE (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%RDITE
ENDIF
READ (KLUN) LRDIGFLE
IF (LRDIGFLE) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%RDIGFLE (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  READ (KLUN) YD%RDIGFLE
ENDIF
READ (KLUN) LRDIPDE
IF (LRDIPDE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDIPDE (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%RDIPDE
ENDIF
READ (KLUN) LRDIVDE
IF (LRDIVDE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDIVDE (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%RDIVDE
ENDIF
READ (KLUN) LRDISPE
IF (LRDISPE) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%RDISPE (IL1(1):IU1(1)))
  READ (KLUN) YD%RDISPE
ENDIF
READ (KLUN) LRDSVORE
IF (LRDSVORE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDSVORE (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%RDSVORE
ENDIF
READ (KLUN) LRDSDIVE
IF (LRDSDIVE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDSDIVE (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%RDSDIVE
ENDIF
READ (KLUN) LRDSVDE
IF (LRDSVDE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDSVDE (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%RDSVDE
ENDIF
READ (KLUN) LREFILV
IF (LREFILV) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%REFILV (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%REFILV
ENDIF
READ (KLUN) LREFILD
IF (LREFILD) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%REFILD (IL2(1):IU2(1), IL2(2):IU2(2)))
  READ (KLUN) YD%REFILD
ENDIF
READ (KLUN) YD%LESIDG
READ (KLUN) YD%RTHRESIDG
READ (KLUN) YD%XMALD
READ (KLUN) YD%TCDIS
END SUBROUTINE


SUBROUTINE COPY_TEDYN (YD, LDCREATED)
IMPLICIT NONE
TYPE (TEDYN), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED
LOGICAL :: LLCREATED
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV

LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$acc enter data create (YD)
  !$acc update device (YD)
ENDIF
LRDIVORE = ALLOCATED (YD%RDIVORE)
IF (LRDIVORE) THEN
  !$acc enter data create (YD%RDIVORE)
  !$acc update device (YD%RDIVORE)
  !$acc enter data attach (YD%RDIVORE)
ENDIF

LRDIDIVE = ALLOCATED (YD%RDIDIVE)
IF (LRDIDIVE) THEN
  !$acc enter data create (YD%RDIDIVE)
  !$acc update device (YD%RDIDIVE)
  !$acc enter data attach (YD%RDIDIVE)
ENDIF

LRDITE = ALLOCATED (YD%RDITE)
IF (LRDITE) THEN
  !$acc enter data create (YD%RDITE)
  !$acc update device (YD%RDITE)
  !$acc enter data attach (YD%RDITE)
ENDIF

LRDIGFLE = ALLOCATED (YD%RDIGFLE)
IF (LRDIGFLE) THEN
  !$acc enter data create (YD%RDIGFLE)
  !$acc update device (YD%RDIGFLE)
  !$acc enter data attach (YD%RDIGFLE)
ENDIF

LRDIPDE = ALLOCATED (YD%RDIPDE)
IF (LRDIPDE) THEN
  !$acc enter data create (YD%RDIPDE)
  !$acc update device (YD%RDIPDE)
  !$acc enter data attach (YD%RDIPDE)
ENDIF

LRDIVDE = ALLOCATED (YD%RDIVDE)
IF (LRDIVDE) THEN
  !$acc enter data create (YD%RDIVDE)
  !$acc update device (YD%RDIVDE)
  !$acc enter data attach (YD%RDIVDE)
ENDIF

LRDISPE = ALLOCATED (YD%RDISPE)
IF (LRDISPE) THEN
  !$acc enter data create (YD%RDISPE)
  !$acc update device (YD%RDISPE)
  !$acc enter data attach (YD%RDISPE)
ENDIF

LRDSVORE = ALLOCATED (YD%RDSVORE)
IF (LRDSVORE) THEN
  !$acc enter data create (YD%RDSVORE)
  !$acc update device (YD%RDSVORE)
  !$acc enter data attach (YD%RDSVORE)
ENDIF

LRDSDIVE = ALLOCATED (YD%RDSDIVE)
IF (LRDSDIVE) THEN
  !$acc enter data create (YD%RDSDIVE)
  !$acc update device (YD%RDSDIVE)
  !$acc enter data attach (YD%RDSDIVE)
ENDIF

LRDSVDE = ALLOCATED (YD%RDSVDE)
IF (LRDSVDE) THEN
  !$acc enter data create (YD%RDSVDE)
  !$acc update device (YD%RDSVDE)
  !$acc enter data attach (YD%RDSVDE)
ENDIF

LREFILV = ALLOCATED (YD%REFILV)
IF (LREFILV) THEN
  !$acc enter data create (YD%REFILV)
  !$acc update device (YD%REFILV)
  !$acc enter data attach (YD%REFILV)
ENDIF

LREFILD = ALLOCATED (YD%REFILD)
IF (LREFILD) THEN
  !$acc enter data create (YD%REFILD)
  !$acc update device (YD%REFILD)
  !$acc enter data attach (YD%REFILD)
ENDIF





END SUBROUTINE

SUBROUTINE WIPE_TEDYN (YD, LDDELETED)
IMPLICIT NONE
TYPE (TEDYN), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED
LOGICAL :: LLDELETED
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV

LRDIVORE = ALLOCATED (YD%RDIVORE)
IF (LRDIVORE) THEN
  !$acc exit data detach (YD%RDIVORE)
  !$acc exit data delete (YD%RDIVORE)
ENDIF

LRDIDIVE = ALLOCATED (YD%RDIDIVE)
IF (LRDIDIVE) THEN
  !$acc exit data detach (YD%RDIDIVE)
  !$acc exit data delete (YD%RDIDIVE)
ENDIF

LRDITE = ALLOCATED (YD%RDITE)
IF (LRDITE) THEN
  !$acc exit data detach (YD%RDITE)
  !$acc exit data delete (YD%RDITE)
ENDIF

LRDIGFLE = ALLOCATED (YD%RDIGFLE)
IF (LRDIGFLE) THEN
  !$acc exit data detach (YD%RDIGFLE)
  !$acc exit data delete (YD%RDIGFLE)
ENDIF

LRDIPDE = ALLOCATED (YD%RDIPDE)
IF (LRDIPDE) THEN
  !$acc exit data detach (YD%RDIPDE)
  !$acc exit data delete (YD%RDIPDE)
ENDIF

LRDIVDE = ALLOCATED (YD%RDIVDE)
IF (LRDIVDE) THEN
  !$acc exit data detach (YD%RDIVDE)
  !$acc exit data delete (YD%RDIVDE)
ENDIF

LRDISPE = ALLOCATED (YD%RDISPE)
IF (LRDISPE) THEN
  !$acc exit data detach (YD%RDISPE)
  !$acc exit data delete (YD%RDISPE)
ENDIF

LRDSVORE = ALLOCATED (YD%RDSVORE)
IF (LRDSVORE) THEN
  !$acc exit data detach (YD%RDSVORE)
  !$acc exit data delete (YD%RDSVORE)
ENDIF

LRDSDIVE = ALLOCATED (YD%RDSDIVE)
IF (LRDSDIVE) THEN
  !$acc exit data detach (YD%RDSDIVE)
  !$acc exit data delete (YD%RDSDIVE)
ENDIF

LRDSVDE = ALLOCATED (YD%RDSVDE)
IF (LRDSVDE) THEN
  !$acc exit data detach (YD%RDSVDE)
  !$acc exit data delete (YD%RDSVDE)
ENDIF

LREFILV = ALLOCATED (YD%REFILV)
IF (LREFILV) THEN
  !$acc exit data detach (YD%REFILV)
  !$acc exit data delete (YD%REFILV)
ENDIF

LREFILD = ALLOCATED (YD%REFILD)
IF (LREFILD) THEN
  !$acc exit data detach (YD%REFILD)
  !$acc exit data delete (YD%REFILD)
ENDIF





LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$acc exit data delete (YD)
ENDIF
END SUBROUTINE



END MODULE
