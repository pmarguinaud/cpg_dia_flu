MODULE UTIL_TEAERD_MOD

USE YOEAERD, ONLY : TEAERD


INTERFACE SAVE
MODULE PROCEDURE SAVE_TEAERD
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE LOAD_TEAERD
END INTERFACE

INTERFACE COPY
MODULE PROCEDURE COPY_TEAERD
END INTERFACE

INTERFACE WIPE
MODULE PROCEDURE WIPE_TEAERD
END INTERFACE



CONTAINS

SUBROUTINE SAVE_TEAERD (KLUN, YD)
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
CLASS (TEAERD), INTENT (IN), TARGET :: YD
LOGICAL :: LCVDAED, LCVDAEL, LCVDAES, LCVDAEU

LCVDAES = ALLOCATED (YD%CVDAES)
WRITE (KLUN) LCVDAES
IF (LCVDAES) THEN
  WRITE (KLUN) LBOUND (YD%CVDAES)
  WRITE (KLUN) UBOUND (YD%CVDAES)
  WRITE (KLUN) YD%CVDAES
ENDIF
LCVDAEL = ALLOCATED (YD%CVDAEL)
WRITE (KLUN) LCVDAEL
IF (LCVDAEL) THEN
  WRITE (KLUN) LBOUND (YD%CVDAEL)
  WRITE (KLUN) UBOUND (YD%CVDAEL)
  WRITE (KLUN) YD%CVDAEL
ENDIF
LCVDAEU = ALLOCATED (YD%CVDAEU)
WRITE (KLUN) LCVDAEU
IF (LCVDAEU) THEN
  WRITE (KLUN) LBOUND (YD%CVDAEU)
  WRITE (KLUN) UBOUND (YD%CVDAEU)
  WRITE (KLUN) YD%CVDAEU
ENDIF
LCVDAED = ALLOCATED (YD%CVDAED)
WRITE (KLUN) LCVDAED
IF (LCVDAED) THEN
  WRITE (KLUN) LBOUND (YD%CVDAED)
  WRITE (KLUN) UBOUND (YD%CVDAED)
  WRITE (KLUN) YD%CVDAED
ENDIF
WRITE (KLUN) YD%RAESC
WRITE (KLUN) YD%RAESS
WRITE (KLUN) YD%RAELC
WRITE (KLUN) YD%RAELS
WRITE (KLUN) YD%RAEUC
WRITE (KLUN) YD%RAEUS
WRITE (KLUN) YD%RAEDC
WRITE (KLUN) YD%RAEDS
WRITE (KLUN) YD%RCAEOPS
WRITE (KLUN) YD%RCAEOPL
WRITE (KLUN) YD%RCAEOPU
WRITE (KLUN) YD%RCAEOPD
WRITE (KLUN) YD%RCTRBGA
WRITE (KLUN) YD%RCVOBGA
WRITE (KLUN) YD%RCSTBGA
WRITE (KLUN) YD%RCTRPT
WRITE (KLUN) YD%RCAEADK
WRITE (KLUN) YD%RCAEADM
WRITE (KLUN) YD%RCAEROS
END SUBROUTINE

SUBROUTINE LOAD_TEAERD (KLUN, YD)
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
CLASS (TEAERD), INTENT (OUT), TARGET :: YD
INTEGER :: IL1(1), IU1(1)
LOGICAL :: LCVDAED, LCVDAEL, LCVDAES, LCVDAEU

READ (KLUN) LCVDAES
IF (LCVDAES) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%CVDAES (IL1(1):IU1(1)))
  READ (KLUN) YD%CVDAES
ENDIF
READ (KLUN) LCVDAEL
IF (LCVDAEL) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%CVDAEL (IL1(1):IU1(1)))
  READ (KLUN) YD%CVDAEL
ENDIF
READ (KLUN) LCVDAEU
IF (LCVDAEU) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%CVDAEU (IL1(1):IU1(1)))
  READ (KLUN) YD%CVDAEU
ENDIF
READ (KLUN) LCVDAED
IF (LCVDAED) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%CVDAED (IL1(1):IU1(1)))
  READ (KLUN) YD%CVDAED
ENDIF
READ (KLUN) YD%RAESC
READ (KLUN) YD%RAESS
READ (KLUN) YD%RAELC
READ (KLUN) YD%RAELS
READ (KLUN) YD%RAEUC
READ (KLUN) YD%RAEUS
READ (KLUN) YD%RAEDC
READ (KLUN) YD%RAEDS
READ (KLUN) YD%RCAEOPS
READ (KLUN) YD%RCAEOPL
READ (KLUN) YD%RCAEOPU
READ (KLUN) YD%RCAEOPD
READ (KLUN) YD%RCTRBGA
READ (KLUN) YD%RCVOBGA
READ (KLUN) YD%RCSTBGA
READ (KLUN) YD%RCTRPT
READ (KLUN) YD%RCAEADK
READ (KLUN) YD%RCAEADM
READ (KLUN) YD%RCAEROS
END SUBROUTINE


SUBROUTINE COPY_TEAERD (YD, LDCREATED)
IMPLICIT NONE
CLASS (TEAERD), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED
LOGICAL :: LLCREATED
LOGICAL :: LCVDAED, LCVDAEL, LCVDAES, LCVDAEU

LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$acc enter data create (YD)
  !$acc update device (YD)
ENDIF
LCVDAES = ALLOCATED (YD%CVDAES)
IF (LCVDAES) THEN
  !$acc enter data create (YD%CVDAES)
  !$acc update device (YD%CVDAES)
  !$acc enter data attach (YD%CVDAES)
ENDIF

LCVDAEL = ALLOCATED (YD%CVDAEL)
IF (LCVDAEL) THEN
  !$acc enter data create (YD%CVDAEL)
  !$acc update device (YD%CVDAEL)
  !$acc enter data attach (YD%CVDAEL)
ENDIF

LCVDAEU = ALLOCATED (YD%CVDAEU)
IF (LCVDAEU) THEN
  !$acc enter data create (YD%CVDAEU)
  !$acc update device (YD%CVDAEU)
  !$acc enter data attach (YD%CVDAEU)
ENDIF

LCVDAED = ALLOCATED (YD%CVDAED)
IF (LCVDAED) THEN
  !$acc enter data create (YD%CVDAED)
  !$acc update device (YD%CVDAED)
  !$acc enter data attach (YD%CVDAED)
ENDIF




















END SUBROUTINE

SUBROUTINE WIPE_TEAERD (YD, LDDELETED)
IMPLICIT NONE
CLASS (TEAERD), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED
LOGICAL :: LLDELETED
LOGICAL :: LCVDAED, LCVDAEL, LCVDAES, LCVDAEU

LCVDAES = ALLOCATED (YD%CVDAES)
IF (LCVDAES) THEN
  !$acc exit data detach (YD%CVDAES)
  !$acc exit data delete (YD%CVDAES)
ENDIF

LCVDAEL = ALLOCATED (YD%CVDAEL)
IF (LCVDAEL) THEN
  !$acc exit data detach (YD%CVDAEL)
  !$acc exit data delete (YD%CVDAEL)
ENDIF

LCVDAEU = ALLOCATED (YD%CVDAEU)
IF (LCVDAEU) THEN
  !$acc exit data detach (YD%CVDAEU)
  !$acc exit data delete (YD%CVDAEU)
ENDIF

LCVDAED = ALLOCATED (YD%CVDAED)
IF (LCVDAED) THEN
  !$acc exit data detach (YD%CVDAED)
  !$acc exit data delete (YD%CVDAED)
ENDIF




















LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$acc exit data delete (YD)
ENDIF
END SUBROUTINE



END MODULE
