MODULE UTIL_TCSGLEG_MOD

USE YOMLEG, ONLY : TCSGLEG


INTERFACE SAVE
MODULE PROCEDURE SAVE_TCSGLEG
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE LOAD_TCSGLEG
END INTERFACE

INTERFACE COPY
MODULE PROCEDURE COPY_TCSGLEG
END INTERFACE

INTERFACE WIPE
MODULE PROCEDURE WIPE_TCSGLEG
END INTERFACE



CONTAINS

SUBROUTINE SAVE_TCSGLEG (KLUN, YD)
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (TCSGLEG), INTENT (IN), TARGET :: YD
LOGICAL :: LR1MU2, LR1MUA, LR1MUI, LR1QM2, LRACTHE, LRLATI, LRLATIG, LRMU, LRSQM2, LRW

LRW = ALLOCATED (YD%RW)
WRITE (KLUN) LRW
IF (LRW) THEN
  WRITE (KLUN) LBOUND (YD%RW)
  WRITE (KLUN) UBOUND (YD%RW)
  WRITE (KLUN) YD%RW
ENDIF
LRMU = ALLOCATED (YD%RMU)
WRITE (KLUN) LRMU
IF (LRMU) THEN
  WRITE (KLUN) LBOUND (YD%RMU)
  WRITE (KLUN) UBOUND (YD%RMU)
  WRITE (KLUN) YD%RMU
ENDIF
LR1MU2 = ALLOCATED (YD%R1MU2)
WRITE (KLUN) LR1MU2
IF (LR1MU2) THEN
  WRITE (KLUN) LBOUND (YD%R1MU2)
  WRITE (KLUN) UBOUND (YD%R1MU2)
  WRITE (KLUN) YD%R1MU2
ENDIF
LR1MUI = ALLOCATED (YD%R1MUI)
WRITE (KLUN) LR1MUI
IF (LR1MUI) THEN
  WRITE (KLUN) LBOUND (YD%R1MUI)
  WRITE (KLUN) UBOUND (YD%R1MUI)
  WRITE (KLUN) YD%R1MUI
ENDIF
LR1MUA = ALLOCATED (YD%R1MUA)
WRITE (KLUN) LR1MUA
IF (LR1MUA) THEN
  WRITE (KLUN) LBOUND (YD%R1MUA)
  WRITE (KLUN) UBOUND (YD%R1MUA)
  WRITE (KLUN) YD%R1MUA
ENDIF
LRSQM2 = ALLOCATED (YD%RSQM2)
WRITE (KLUN) LRSQM2
IF (LRSQM2) THEN
  WRITE (KLUN) LBOUND (YD%RSQM2)
  WRITE (KLUN) UBOUND (YD%RSQM2)
  WRITE (KLUN) YD%RSQM2
ENDIF
LR1QM2 = ALLOCATED (YD%R1QM2)
WRITE (KLUN) LR1QM2
IF (LR1QM2) THEN
  WRITE (KLUN) LBOUND (YD%R1QM2)
  WRITE (KLUN) UBOUND (YD%R1QM2)
  WRITE (KLUN) YD%R1QM2
ENDIF
LRACTHE = ALLOCATED (YD%RACTHE)
WRITE (KLUN) LRACTHE
IF (LRACTHE) THEN
  WRITE (KLUN) LBOUND (YD%RACTHE)
  WRITE (KLUN) UBOUND (YD%RACTHE)
  WRITE (KLUN) YD%RACTHE
ENDIF
LRLATIG = ALLOCATED (YD%RLATIG)
WRITE (KLUN) LRLATIG
IF (LRLATIG) THEN
  WRITE (KLUN) LBOUND (YD%RLATIG)
  WRITE (KLUN) UBOUND (YD%RLATIG)
  WRITE (KLUN) YD%RLATIG
ENDIF
LRLATI = ALLOCATED (YD%RLATI)
WRITE (KLUN) LRLATI
IF (LRLATI) THEN
  WRITE (KLUN) LBOUND (YD%RLATI)
  WRITE (KLUN) UBOUND (YD%RLATI)
  WRITE (KLUN) YD%RLATI
ENDIF
END SUBROUTINE

SUBROUTINE LOAD_TCSGLEG (KLUN, YD)
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (TCSGLEG), INTENT (OUT), TARGET :: YD
INTEGER :: IL1(1), IU1(1)
LOGICAL :: LR1MU2, LR1MUA, LR1MUI, LR1QM2, LRACTHE, LRLATI, LRLATIG, LRMU, LRSQM2, LRW

READ (KLUN) LRW
IF (LRW) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%RW (IL1(1):IU1(1)))
  READ (KLUN) YD%RW
ENDIF
READ (KLUN) LRMU
IF (LRMU) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%RMU (IL1(1):IU1(1)))
  READ (KLUN) YD%RMU
ENDIF
READ (KLUN) LR1MU2
IF (LR1MU2) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%R1MU2 (IL1(1):IU1(1)))
  READ (KLUN) YD%R1MU2
ENDIF
READ (KLUN) LR1MUI
IF (LR1MUI) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%R1MUI (IL1(1):IU1(1)))
  READ (KLUN) YD%R1MUI
ENDIF
READ (KLUN) LR1MUA
IF (LR1MUA) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%R1MUA (IL1(1):IU1(1)))
  READ (KLUN) YD%R1MUA
ENDIF
READ (KLUN) LRSQM2
IF (LRSQM2) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%RSQM2 (IL1(1):IU1(1)))
  READ (KLUN) YD%RSQM2
ENDIF
READ (KLUN) LR1QM2
IF (LR1QM2) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%R1QM2 (IL1(1):IU1(1)))
  READ (KLUN) YD%R1QM2
ENDIF
READ (KLUN) LRACTHE
IF (LRACTHE) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%RACTHE (IL1(1):IU1(1)))
  READ (KLUN) YD%RACTHE
ENDIF
READ (KLUN) LRLATIG
IF (LRLATIG) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%RLATIG (IL1(1):IU1(1)))
  READ (KLUN) YD%RLATIG
ENDIF
READ (KLUN) LRLATI
IF (LRLATI) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%RLATI (IL1(1):IU1(1)))
  READ (KLUN) YD%RLATI
ENDIF
END SUBROUTINE


SUBROUTINE COPY_TCSGLEG (YD, LDCREATED)
IMPLICIT NONE
TYPE (TCSGLEG), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED
LOGICAL :: LLCREATED
LOGICAL :: LR1MU2, LR1MUA, LR1MUI, LR1QM2, LRACTHE, LRLATI, LRLATIG, LRMU, LRSQM2, LRW

LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$acc enter data create (YD)
  !$acc update device (YD)
ENDIF
LRW = ALLOCATED (YD%RW)
IF (LRW) THEN
  !$acc enter data create (YD%RW)
  !$acc update device (YD%RW)
  !$acc enter data attach (YD%RW)
ENDIF

LRMU = ALLOCATED (YD%RMU)
IF (LRMU) THEN
  !$acc enter data create (YD%RMU)
  !$acc update device (YD%RMU)
  !$acc enter data attach (YD%RMU)
ENDIF

LR1MU2 = ALLOCATED (YD%R1MU2)
IF (LR1MU2) THEN
  !$acc enter data create (YD%R1MU2)
  !$acc update device (YD%R1MU2)
  !$acc enter data attach (YD%R1MU2)
ENDIF

LR1MUI = ALLOCATED (YD%R1MUI)
IF (LR1MUI) THEN
  !$acc enter data create (YD%R1MUI)
  !$acc update device (YD%R1MUI)
  !$acc enter data attach (YD%R1MUI)
ENDIF

LR1MUA = ALLOCATED (YD%R1MUA)
IF (LR1MUA) THEN
  !$acc enter data create (YD%R1MUA)
  !$acc update device (YD%R1MUA)
  !$acc enter data attach (YD%R1MUA)
ENDIF

LRSQM2 = ALLOCATED (YD%RSQM2)
IF (LRSQM2) THEN
  !$acc enter data create (YD%RSQM2)
  !$acc update device (YD%RSQM2)
  !$acc enter data attach (YD%RSQM2)
ENDIF

LR1QM2 = ALLOCATED (YD%R1QM2)
IF (LR1QM2) THEN
  !$acc enter data create (YD%R1QM2)
  !$acc update device (YD%R1QM2)
  !$acc enter data attach (YD%R1QM2)
ENDIF

LRACTHE = ALLOCATED (YD%RACTHE)
IF (LRACTHE) THEN
  !$acc enter data create (YD%RACTHE)
  !$acc update device (YD%RACTHE)
  !$acc enter data attach (YD%RACTHE)
ENDIF

LRLATIG = ALLOCATED (YD%RLATIG)
IF (LRLATIG) THEN
  !$acc enter data create (YD%RLATIG)
  !$acc update device (YD%RLATIG)
  !$acc enter data attach (YD%RLATIG)
ENDIF

LRLATI = ALLOCATED (YD%RLATI)
IF (LRLATI) THEN
  !$acc enter data create (YD%RLATI)
  !$acc update device (YD%RLATI)
  !$acc enter data attach (YD%RLATI)
ENDIF

END SUBROUTINE

SUBROUTINE WIPE_TCSGLEG (YD, LDDELETED)
IMPLICIT NONE
TYPE (TCSGLEG), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED
LOGICAL :: LLDELETED
LOGICAL :: LR1MU2, LR1MUA, LR1MUI, LR1QM2, LRACTHE, LRLATI, LRLATIG, LRMU, LRSQM2, LRW

LRW = ALLOCATED (YD%RW)
IF (LRW) THEN
  !$acc exit data detach (YD%RW)
  !$acc exit data delete (YD%RW)
ENDIF

LRMU = ALLOCATED (YD%RMU)
IF (LRMU) THEN
  !$acc exit data detach (YD%RMU)
  !$acc exit data delete (YD%RMU)
ENDIF

LR1MU2 = ALLOCATED (YD%R1MU2)
IF (LR1MU2) THEN
  !$acc exit data detach (YD%R1MU2)
  !$acc exit data delete (YD%R1MU2)
ENDIF

LR1MUI = ALLOCATED (YD%R1MUI)
IF (LR1MUI) THEN
  !$acc exit data detach (YD%R1MUI)
  !$acc exit data delete (YD%R1MUI)
ENDIF

LR1MUA = ALLOCATED (YD%R1MUA)
IF (LR1MUA) THEN
  !$acc exit data detach (YD%R1MUA)
  !$acc exit data delete (YD%R1MUA)
ENDIF

LRSQM2 = ALLOCATED (YD%RSQM2)
IF (LRSQM2) THEN
  !$acc exit data detach (YD%RSQM2)
  !$acc exit data delete (YD%RSQM2)
ENDIF

LR1QM2 = ALLOCATED (YD%R1QM2)
IF (LR1QM2) THEN
  !$acc exit data detach (YD%R1QM2)
  !$acc exit data delete (YD%R1QM2)
ENDIF

LRACTHE = ALLOCATED (YD%RACTHE)
IF (LRACTHE) THEN
  !$acc exit data detach (YD%RACTHE)
  !$acc exit data delete (YD%RACTHE)
ENDIF

LRLATIG = ALLOCATED (YD%RLATIG)
IF (LRLATIG) THEN
  !$acc exit data detach (YD%RLATIG)
  !$acc exit data delete (YD%RLATIG)
ENDIF

LRLATI = ALLOCATED (YD%RLATI)
IF (LRLATI) THEN
  !$acc exit data detach (YD%RLATI)
  !$acc exit data delete (YD%RLATI)
ENDIF

LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$acc exit data delete (YD)
ENDIF
END SUBROUTINE



END MODULE
