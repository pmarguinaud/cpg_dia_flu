MODULE UTIL_TEAERSNK_MOD

USE YOEAERSNK, ONLY : TEAERSNK


INTERFACE SAVE
MODULE PROCEDURE SAVE_TEAERSNK
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE LOAD_TEAERSNK
END INTERFACE

INTERFACE COPY
MODULE PROCEDURE COPY_TEAERSNK
END INTERFACE

INTERFACE WIPE
MODULE PROCEDURE WIPE_TEAERSNK
END INTERFACE



CONTAINS

SUBROUTINE SAVE_TEAERSNK (KLUN, YD)
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
CLASS (TEAERSNK), INTENT (IN), TARGET :: YD

WRITE (KLUN) YD%NDRYDEPVEL_DYN
WRITE (KLUN) YD%NDRYDEP
WRITE (KLUN) YD%R_R
WRITE (KLUN) YD%R_S
WRITE (KLUN) YD%RAERTS
WRITE (KLUN) YD%RFRAER
WRITE (KLUN) YD%RRHTAB
WRITE (KLUN) YD%RSSGROWTH_RHTAB
WRITE (KLUN) YD%RSSDENS_RHTAB
WRITE (KLUN) YD%RMMD_DD
WRITE (KLUN) YD%RRHO_DD
WRITE (KLUN) YD%RMMD_NI
WRITE (KLUN) YD%RRHO_NI
WRITE (KLUN) YD%RMMD_SS
WRITE (KLUN) YD%RRHO_SS
WRITE (KLUN) YD%RHO_WAT
WRITE (KLUN) YD%RHO_ICE
WRITE (KLUN) YD%RHAMAKER
WRITE (KLUN) YD%RSO2CV1
WRITE (KLUN) YD%RSO2CV2
WRITE (KLUN) YD%RSUCV1
WRITE (KLUN) YD%RSUCV2
WRITE (KLUN) YD%RVSO2CV1
WRITE (KLUN) YD%RVSO2CV2
END SUBROUTINE

SUBROUTINE LOAD_TEAERSNK (KLUN, YD)
IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
CLASS (TEAERSNK), INTENT (OUT), TARGET :: YD

READ (KLUN) YD%NDRYDEPVEL_DYN
READ (KLUN) YD%NDRYDEP
READ (KLUN) YD%R_R
READ (KLUN) YD%R_S
READ (KLUN) YD%RAERTS
READ (KLUN) YD%RFRAER
READ (KLUN) YD%RRHTAB
READ (KLUN) YD%RSSGROWTH_RHTAB
READ (KLUN) YD%RSSDENS_RHTAB
READ (KLUN) YD%RMMD_DD
READ (KLUN) YD%RRHO_DD
READ (KLUN) YD%RMMD_NI
READ (KLUN) YD%RRHO_NI
READ (KLUN) YD%RMMD_SS
READ (KLUN) YD%RRHO_SS
READ (KLUN) YD%RHO_WAT
READ (KLUN) YD%RHO_ICE
READ (KLUN) YD%RHAMAKER
READ (KLUN) YD%RSO2CV1
READ (KLUN) YD%RSO2CV2
READ (KLUN) YD%RSUCV1
READ (KLUN) YD%RSUCV2
READ (KLUN) YD%RVSO2CV1
READ (KLUN) YD%RVSO2CV2
END SUBROUTINE


SUBROUTINE COPY_TEAERSNK (YD, LDCREATED)
IMPLICIT NONE
CLASS (TEAERSNK), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED
LOGICAL :: LLCREATED

LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$acc enter data create (YD)
  !$acc update device (YD)
ENDIF
























END SUBROUTINE

SUBROUTINE WIPE_TEAERSNK (YD, LDDELETED)
IMPLICIT NONE
CLASS (TEAERSNK), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED
LOGICAL :: LLDELETED

























LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$acc exit data delete (YD)
ENDIF
END SUBROUTINE



END MODULE
